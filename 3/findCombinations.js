/**
 * @module findCombinations
 * @type {Function}
 */
typeof module !== "undefined" && module.exports && (module.exports = findCombinations);

/**
 * Поиск вохможных комбинаций в массиве, сумма которых равна N
 * Подразумевается что порядок слогаемых нас не интерессует
 * (Если он все таки интерессует, то стоит дописать функцию, 
 * воссоздающую все возможеные комбинации из выходных результатов.)
 *
 * @param {Array} haystack массив слогаемых
 * @param {Number} N искомая сумма
 * @returns {Array} массив из массивов комбинаций слогаемых =)
 */
function findCombinations( haystack, N ) {
	if(!haystack || !haystack instanceof Array)
		throw new Error('Haystack array as first argument required =(');

	// Number пригодится
	N = (+N || 10);

	// Объект, в качестве ключей которого эл-ты входного массива
	// а ключи - количество вхождений эл-та в исходный массив.
	// Нужно для быстрой сортировки и проходу комбинаций по возрастанию
	// отбрасывая комбинации, сумма которых заведомо больше N
	var values = {};
	for( var i = 0, l = haystack.length >>> 0; i < l; i++ ) {
		if( values.hasOwnProperty( haystack[i] ) ) {
			values[ haystack[i] ]++;
		} else {
			values[ haystack[i] ] = 1;
		}
	}
	// Массив ключей объекта - эл-тов исохдного массива.
	// Сортировочка по возростанию, да
	var keys = Object.keys( values ).sort( function(a, b){
		return a-b;
	} );
	var klen = keys.length >>> 0;

	// Массив результатов поиска
	var results = [];

	// Запуск волкера =)
	for( var i = 0; i < klen; i++ ) {
		// Пришлось учитывать все изменения при вызове, чтобы не делать
		// "холостых" вызовов волкера, которые, как оказалось, уничтожают производительность
		walker( i, +values[ keys[i] ] - 1, +keys[i], [ +keys[i] ] );
		// Если само число из вход. данных есть N.
		// Но игнорировать не стоит, оно прегодится для 
		// отрицательных чисел
		if( +keys[i] === N ) {
			results.push( [+keys[i]] );
		}
	}
	return results;

	/**
	 * Функция выполняющая обход возможных комбинаций
	 * @param {Number} current секущий эл-т из последовательности keys - списка эл-тов исходного массива
	 * @param {Number} left солько осталось экземпляров текущего эл-та
	 * @param {Number} sum сумма всех эл-тов в текущей последовательности
	 * @param {Array} elems массив слогаемых в текущей последовательности
	 * @returns {undefined}
	 */
	function walker( current, left, sum, elems ) {

		// От себя, любименького, может еще что-то и осталось.
		// То самое ветвление с привязкой на то, сколько 
		// экземпляров текущего эл-та пока не использовалось (current, left)
		// Жаль, но elems придется скопировать в новый объект (.slice), чтобы 
		// вызовы ниже не переопределяли elems на этом уровне стека вызова
		//
		// Учет изменениий данных при вызове, так что
		// для вызова для "самого себя" нужно проверить,
		// есть ли от меня вообще что-то =)
		if( left > 0 ) {
			var a = elems.slice(),
				s = +keys[current] + sum;

				a.push( +keys[current] );

			// От самого себя еще что-то осталось и это дает сумму N?
			if( s === N ) {
				results.push(a);
			// Нет так нет, может еще раз себя пропизнуть получится
			} else if( left >= 0 ) {
				walker( current, left - 1, s, a );
			}
		}

		// Если текущего не осталось, есть еще много других эл-тов в последовательности
		for( var i = current + 1; i < klen; i++ ) {
			// Сумма с учетом эл-та на текущей интерации.
			// Делается здесь, повторюсь, чтобы не делать 
			// лишних вызовов волкера
			s = +keys[i] + sum;
			// А сколько эл-та на текущей интерации осталось?
			var le = (+values[ keys[i] ]) - 1;

			// Если не вышли за сумму и не задолжали текущего элемента
			if( s <= N && le >= 0 ) {
				// В любом случае, либо в результаты, 
				// либо в цепочку "дочерних" вызовов поиска,
				// нужен будет текущий список слогаемых
				// в стеке вызовов поиска (волкера)
				a = elems.slice();
				a.push( +keys[i]);

				// Данунафих, правда?
				if( s === N ) {
					results.push(a);
				} else {
					// Продолжение поиска, 
					// вызов уже с учетом посчитанной суммы,
					// солько осталось эл-та и дополненный
					// список слогаемых
					walker( i, le, s, a );
				}
			}
		}
	}
}