/**
 * Тест демонстрирующий преблему скорости производительности старого подхода
 * использовавшего clearTimeout при каждом вызове
 *
 * WTF is there!1??
 * В тестовых данных для кадого тестируемого метода описано
 * 1) вызов дебаунс функции @const calls раз (которые в идеале должны произойти мгновенно)
 * 2) вызов дебаунс функции спустя 300 и 500 мс с момента начала теста
 * это приводит к тому, что первый "Debounce function fired!" будет через 1сек.
 * и второй через 1.7сек после начала теста, с текстом: "width 3"
 *
 * Если первый вызов произошел через
 * (1сек + задержка тика таймера) < time < 1.2сек,
 * или не произошел вовсе, значит debounce метод говняшка
 *
 * Относительно throttle...
 * не самая интересная реализация в плане принципа вызова дебаунцнутых функций
 * Зато! очень шустрая =)
 */

 /**
 * Подключаем две разные реализации для тестирования
 */
var debounce = require('./debounce').debounce,
	old_debounce = require('./oldschool.debounce').debounce,
	throttle = require('./debounce').throttle;

/**
 * Сгодится для красивых и последовательных тестов
 */
var Promise = require('./Promise');

/**
 * Количество одновременных вызовов тестируемой функции
 *
 * АХТУНГ!!!!
 * уменьшить, если первый тест выполняется долше 0.6сек
 * или
 * увеличить, если второй тест быстрее 0.6сек
 * так сохраняется наглядность проблемы
 */
const calls = 500000,
	  /** таймаут дебаунса */
	  testingTimeout = 500,
	  /**
	   * Указывает когда будет вызвана исходная функция,
	   * true - в момент первого вызова, или false - по истичению таймаута
	   */
	  invokeAsap = false;

/** Ололо, скормим это цепочке вызовов тестов */
var tesingFns = [
	debounce,
	old_debounce,
	throttle
];
/** Запуск последовательных тестов */
testing_stack();




/**
 * Функция последовательно запускающая тесты
 * Завязана на промис возвращаемый ф-ей test()
 * @param {Number} i номер текущего теста
 */
function testing_stack(i) {
	i || (i = 0);
	if( i >= tesingFns.length )
		return;

	console.log('\nRunning test #' + i);

	// Когда функция test() резолвит промис, значит закончила все тесты, элементарно)
	test( tesingFns[i] ).then(function(){
		// После резолва в фоне могут оставаться дебаунсы, ожидающие своего таймаута.
		setTimeout(
			function(){
				testing_stack(++i);
			},
			// Запустим ка следующий тест заведомо после такого таймаута + ужасное, но время задержки тика таймера
			testingTimeout + 50
		);
	})
}

/**
 * Функция тестилка
 * @param {Function} _fn функция дебаунса для теста
 * @returns {Promise}
 */
function test( _fn ) {

	// Время начала теста, для того, чтобы понятно было через сколько в консольку выплюнулся текст
	var t = +new Date(),
		// Дебаунсим функцию =D
		fn = _fn(
			function( data ){
				// Когда дебаунс таки вызовет дебаунснатую ф-ю, желательно иметь возможность понять когда она была вызвана,
				// относительно времени начала теста ;-)
				console.log( 'Debounced function fired!\n\t\t\t\tAfter ' + (+new Date - t) + 'ms.' + ( data ? '\t with ' + data : '' ) );
			},
			// Ты уже успел забыть об этих константах? ='(
			testingTimeout,
			invokeAsap
		),
		// Надыж промис веруть =)
		promise = new Promise();


	// И так, и сяк, и эдак
	fn(1);
	fn(2);

	// Эти вызовы не передают никаких аргументов
	// А еще из-за них таймаут дебаунса будет не 500мс, а все 1000!
	setTimeout(fn, 300);
	setTimeout(fn, 500);

	// Дебаунс даже постоит без дела почти 200мс =)
	setTimeout(
		function(){
			fn(3);

			// Это был "последний герой"...
			promise.resolve();
		}, 1200);


	// Считается максимально возможное количество вызовов в секунду для метода.
	// Точнее вызывается много, а потом считаем сколько было в секунду.
	var start = +new Date();
	for(var i = 0; i < calls; i++) {
		fn();
	}
	var secs = ( (+new Date() - start) / 1000 )
	console.log( Math.ceil(calls / secs) + ' fn calls p/s [tested in ' + secs + 's.]' );


	// Пошла жара
	return promise;
}